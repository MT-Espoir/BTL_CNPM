# ROOM BOOKING SYSTEM - ARCHITECTURE DESIGN

## 1. Overview
This document describes the overall architecture of the Room Booking System, including its layers, components, data flow, and deployment topology.

## 2. Architectural Layers

1. **Presentation Layer (Frontend)**
   - React application running in the browser
   - Components: Views, Layouts, Contexts, Routes, Common UI
   - Communicates with backend via REST API

2. **Application Layer (Backend Services)**
   - Node.js + Express.js application
   - Controllers: Handle HTTP requests and responses
   - Services/Business Logic: Validate inputs, enforce rules, orchestrate operations
   - Middleware: Authentication (JWT), Authorization (RBAC), Logging, Error handling

3. **Domain Layer (Models)**
   - ORM-like classes for User, Room, Booking, Device, Notification
   - Encapsulate data structures, validation, and database queries
   - Provide CRUD operations and domain-specific methods

4. **Data Layer (Persistence & Cache)**
   - **MySQL**: Primary relational database for persistent storage
   - **Redis**: In-memory cache for sessions, rate limiting, and performance-critical queries
   - Connection managers under `backend/config`

5. **Infrastructure Layer**
   - File storage for uploaded room images (local filesystem under `uploads/rooms`)
   - SQL scripts and migration tools (`backend/SQL` directory)
   - CI/CD pipelines and monitoring (e.g., GitHub Actions, Docker)

## 3. Component Interaction

1. User interacts with React UI → sends HTTP(s) request
2. `server.js` (Express) routes request to appropriate Router
3. Router applies authentication and authorization middleware
4. Controller invokes domain model methods or service functions
5. Model executes SQL queries via `connect_db.js` or `connect_redis.js`
6. Data is returned to Controller → Controller formats and returns JSON to client
7. Frontend updates UI based on API response

## 4. Deployment Topology

- **Frontend**: Deployed to a static web server or CDN (e.g., Netlify, AWS S3 + CloudFront)
- **Backend**: Node.js app deployed to cloud VM or container orchestration (e.g., Docker + Kubernetes)
- **Database**: MySQL server (managed service or on-prem)
- **Cache**: Redis server
- **Reverse Proxy / Load Balancer**: Nginx or cloud LB in front of backend

```text
                +--------------+         +----------------+      +-----------+
Client Browser ->|  React App   |  API  ->|  Express API   | <-> | MySQL DB  |
 (HTTPS)         +--------------+         +----------------+      +-----------+
                                                ^
                                                |
                                              Redis
                                                |
                                                v
                                       +-------------------+
                                       |  Redis Cache      |
                                       +-------------------+
```  

## 5. Scalability & High Availability

- **Stateless Frontend/Backend**: Horizontal scaling via multiple instances behind LB
- **Database Replication**: Master–slave setup for read scalability and failover
- **Caching**: Redis to reduce DB load for frequently accessed data
- **Autoscaling**: Auto-scale based on CPU/memory or request volume

## 6. Security Considerations

- OAuth2 / JWT for secure session management
- Role-Based Access Control enforced in middleware
- Input validation and sanitization to prevent SQL injection, XSS
- HTTPS for all client-server communications

## 7. CI/CD & Testing

- **Version Control**: Git (branching strategy: main/develop/feature)
- **Continuous Integration**: Automated builds and tests via GitHub Actions
- **Unit & Integration Tests**: Jest (frontend), Mocha/Chai (backend)
- **Code Quality**: ESLint, Prettier, SonarQube
- **Deployment**: Docker images published to registry, orchestration via Kubernetes or Docker Compose

## 8. Monitoring & Logging

- **Application Logs**: Winston or Morgan for structured logging
- **Metrics**: Prometheus + Grafana for performance dashboards
- **Alerts**: Setup alerts for error rates, latency, disk usage

---

This architecture design provides a blueprint for system implementation, ensuring maintainability, scalability, and security.